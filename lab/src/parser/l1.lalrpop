use std::str::FromStr;
use crate::ast::*;

grammar;

pub Program: Box<AnnoAstNode> = {
    "int" "main" "(" ")" "{" "}" => Box::new(Prog { stmts: Vec::new() }.into()),
    "int" "main" "(" ")" "{" <Stmts> "}" => Box::new(Prog { stmts: <> }.into()),
};

Stmts: Vec<Box<AnnoAstNode>> = {
    <ss:Stmts?> <s:Stmt> => {
        match ss {
            None => vec![s],
            Some(ss) => {
                let mut ss = ss;
                ss.push(s);
                ss
            }
        }
    }
}

Term: Box<AnnoAstNode> = {
    "(" <Expr> ")"=> <>,
    <Num> => Box::new(Expr::Num(<>).into()),
    <Ident> => Box::new(Expr::Ident(<>).into())
};

Tier<Op, NextTier>: Box<AnnoAstNode> = {
    Tier<Op, NextTier> Op NextTier => Box::new(Expr::Binop(<>).into()),
    NextTier
};

// This is "pub" only because of test reason for that expression is tricky to parse right
pub(crate) Expr: Box<AnnoAstNode> = {
    Tier<Binop, Factor> => <>,
    "-" <Expr> => Box::new(Expr::Minus(<>).into()),
};

Factor = Tier<FactorOp, Term>;

Lvalue: Box<AnnoAstNode> = {
    <Ident> => Box::new(Lvalue::Ident(<>.to_string()).into()),
    "(" <Lvalue> ")" => Box::new(Lvalue::Lvalue(<>).into()),
};

Decl: Box<AnnoAstNode> = {
    "int" <Ident> => Box::new(Decl::Ident(<>.to_string()).into()),
    "int" <i:Ident> "=" <e:Expr> => Box::new(Decl::IdentInit(i.to_string(), e).into()),
};

Stmt: Box<AnnoAstNode> = {
    <Decl> ";" => Box::new(Stmt::Decl(<>).into()),
    <l:Lvalue> <op:Asnop> <e:Expr> ";" => Box::new(Stmt::Simp(l, op, e).into()),
    "return" <Expr> ";" => Box::new(Stmt::Return(<>).into()),
};

// lexical tokens
Ident: String = <ident> => <>.to_string();
Num: u32 = {
    <DecNum> => <>,
    <HexNum> => <>,
};
DecNum: u32 = {
    "0" => 0,
    <decnum> => u32::from_str(<>).unwrap(),
};
HexNum: u32 = <hexnum> => u32::from_str_radix(&<>[2..], 16).unwrap();

Binop: Box<AnnoAstNode> = {
    "+" => Box::new(Binop::Add.into()),
    "-" => Box::new(Binop::Minus.into()),
};

FactorOp: Box<AnnoAstNode>= {
    "*" => Box::new(Binop::Mul.into()),
    "/" => Box::new(Binop::Div.into()),
    "%" => Box::new(Binop::Mod.into()),
};

Asnop: Box<AnnoAstNode> = {
    "=" => Box::new(Asnop::Equal.into()),
    "+=" => Box::new(Asnop::AddEq.into()),
    "-=" => Box::new(Asnop::MinEq.into()),
    "*=" => Box::new(Asnop::MulEq.into()),
    "/=" => Box::new(Asnop::DivEq.into()),
    "%=" => Box::new(Asnop::ModEq.into()),
};
// TODO: add reserved words check (reserved cannot be used as identifier)
// Reserved: Stmt = <r"(struct|typedef|if|else|while|for|continue|break|return|assert|true|false|NULL|alloc|alloc_array|int|bool|void|char|string)"> => Stmt:Error(<>.to_string());

match {
    "main",
    "int",
    "(",
    ")",
    "{",
    "}",
    ";",
    "return",
    "0",
    "+",
    "*",
    "-",
    "/",
    "%",
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "=",
    r"[A-Za-z_][A-Za-z0-9]*" => ident,
    r"[1-9][0-9]*" => decnum,
    r"0[xX][0-9a-fA-F]+" => hexnum,
}
